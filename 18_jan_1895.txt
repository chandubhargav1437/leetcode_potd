class Solution {
public:
    int largestMagicSquare(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        
        // 1. Build Prefix Sum Arrays
        // rowSum[i][j] stores the sum of the i-th row up to column j-1
        // colSum[i][j] stores the sum of the j-th column up to row i-1
        // We use 'long long' to prevent integer overflow during addition
        vector<vector<long long>> rowSum(m, vector<long long>(n + 1, 0));
        vector<vector<long long>> colSum(m + 1, vector<long long>(n, 0));

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                rowSum[i][j + 1] = rowSum[i][j] + grid[i][j];
                colSum[i + 1][j] = colSum[i][j] + grid[i][j];
            }
        }

        // 2. Iterate size 'k' from largest possible down to 2
        // The first valid magic square we find is guaranteed to be the largest
        for (int k = min(m, n); k > 1; --k) {
            
            // Iterate over every possible top-left corner (i, j)
            for (int i = 0; i <= m - k; ++i) {
                for (int j = 0; j <= n - k; ++j) {
                    
                    // A. Calculate Diagonal Sums
                    long long d1 = 0, d2 = 0;
                    for (int l = 0; l < k; ++l) {
                        d1 += grid[i + l][j + l];             // Top-Left to Bottom-Right
                        d2 += grid[i + l][j + k - 1 - l];     // Top-Right to Bottom-Left
                    }
                    
                    // Optimization: If diagonals don't match, skip row/col checks
                    if (d1 != d2) continue;
                    
                    long long target = d1;
                    bool isMagic = true;

                    // B. Check Rows using Prefix Sums
                    for (int r = 0; r < k; ++r) {
                        // Sum of row (i+r) from col j to j+k-1
                        if (rowSum[i + r][j + k] - rowSum[i + r][j] != target) {
                            isMagic = false;
                            break;
                        }
                    }
                    if (!isMagic) continue;

                    // C. Check Columns using Prefix Sums
                    for (int c = 0; c < k; ++c) {
                        // Sum of col (j+c) from row i to i+k-1
                        if (colSum[i + k][j + c] - colSum[i][j + c] != target) {
                            isMagic = false;
                            break;
                        }
                    }

                    if (isMagic) return k;
                }
            }
        }

        // If no square of size > 1 works, any single cell is a 1x1 magic square
        return 1;
    }
};