class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.length();
        int n = s2.length();

        // Use a 1D DP array to store the results of the previous row.
        // dp[j] represents the minimum delete sum for s1[0...i] and s2[0...j].
        // Size is n + 1 to handle the base case where s2 is empty.
        std::vector<int> dp(n + 1, 0);

        // Base Case: When s1 is empty (row 0), the cost is the cumulative
        // ASCII sum of all characters in s2.
        for (int j = 1; j <= n; ++j) {
            dp[j] = dp[j - 1] + s2[j - 1];
        }

        // Iterate through each character of s1 (representing rows 1 to m)
        for (int i = 1; i <= m; ++i) {
            // 'prev_diag' stores the value of dp[j-1] from the PREVIOUS row (diagonal value).
            // Initially, for column 0, it is dp[0] from the previous row.
            int prev_diag = dp[0];

            // Update dp[0] for the current row:
            // If s2 is empty, cost is cumulative sum of s1 up to current char i.
            dp[0] += s1[i - 1];

            for (int j = 1; j <= n; ++j) {
                // Store the current dp[j] (which is from the previous row) 
                // because it will become 'prev_diag' for the next iteration of j.
                int temp = dp[j];

                if (s1[i - 1] == s2[j - 1]) {
                    // Characters match: Take value from diagonal (i-1, j-1)
                    dp[j] = prev_diag;
                } else {
                    // Characters differ: Take min of deleting from s1 or s2.
                    // dp[j] (current val) represents cost if we delete s1[i-1] (uses row i-1)
                    // dp[j-1] (new val) represents cost if we delete s2[j-1] (uses row i)
                    dp[j] = std::min(dp[j] + s1[i - 1], dp[j - 1] + s2[j - 1]);
                }

                // Update prev_diag for the next column
                prev_diag = temp;
            }
        }

        return dp[n];
    }
};